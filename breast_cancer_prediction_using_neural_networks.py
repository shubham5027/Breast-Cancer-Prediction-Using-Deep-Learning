# -*- coding: utf-8 -*-
"""Breast_Cancer_Prediction_Using_Neural_Networks.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1T1r_WMD8SZp_pJ6krOsI5JwxpEk3SFh9
"""

import pandas as pd
df=pd.read_csv('/content/data (1).csv')

df.head()

del df['Unnamed: 32']

X=df.drop(['id','diagnosis'],axis=1)
y=df['diagnosis']

from sklearn.model_selection import train_test_split
X_train,X_test,y_train,y_test=train_test_split(X,y,test_size=0.2,random_state=32)

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.pipeline import Pipeline
from sklearn.compose import ColumnTransformer
from sklearn.impute import SimpleImputer
from sklearn.preprocessing import OneHotEncoder, OrdinalEncoder, StandardScaler, MinMaxScaler
from sklearn.preprocessing import FunctionTransformer
from sklearn.base import BaseEstimator, TransformerMixin

class CustomFeatureEngineering(BaseEstimator, TransformerMixin):
    def fit(self, X, y=None):
        return self

    def transform(self, X, y=None):
        return X


#  columns are numeric and categorical
numeric_features = X_train.select_dtypes(include=['int64', 'float64']).columns
categorical_features = X_train.select_dtypes(include=['object']).columns

# numeric and categorical pipelines
numeric_pipeline = Pipeline(steps=[
    ('imputer', SimpleImputer(strategy='mean')),
    ('scaler', StandardScaler())
])

categorical_pipeline = Pipeline(steps=[
    ('imputer', SimpleImputer(strategy='constant', fill_value='missing')),
    ('onehot', OneHotEncoder(handle_unknown='ignore'))
])


feature_engineering_pipeline = Pipeline(steps=[
    ('custom_engineering', CustomFeatureEngineering())
])

# Combine
preprocessor = ColumnTransformer(
    transformers=[
        ('num', numeric_pipeline, numeric_features),
        ('cat', categorical_pipeline, categorical_features)
    ],
    remainder='passthrough'
)


full_pipeline = Pipeline(steps=[
    ('preprocessor', preprocessor),
    ('feature_engineering', feature_engineering_pipeline)
])


X_train_processed = full_pipeline.fit_transform(X_train)
X_test_processed = full_pipeline.transform(X_test)

#y_train,y_test data
from sklearn.preprocessing import LabelEncoder
label_encoder = LabelEncoder()
y_train_encoded = label_encoder.fit_transform(y_train)
y_test_encoded = label_encoder.transform(y_test)

pip install -q -U keras-tuner

from tensorflow import keras
from keras.models import Sequential
from keras.layers import Dense
from keras.callbacks import EarlyStopping
import keras_tuner
from kerastuner.tuners import RandomSearch
from tensorflow.keras import layers

def build_model(hp):

    model = keras.Sequential()
    # Add variable number of layers
    for i in range(hp.Int('num_layers', min_value=1, max_value=5)):
        model.add(layers.Dense(units=hp.Int(f'layer_{i}_units', min_value=32, max_value=512, step=32),
                               activation=hp.Choice(f'layer_{i}_activation', values=['relu', 'tanh', 'sigmoid',]),
                               kernel_initializer=hp.Choice(f'layer_{i}_kernel_initializer', values=['glorot_uniform', 'he_normal', 'lecun_normal']),
                               kernel_regularizer=hp.Choice(f'layer_{i}_kernel_regularizer', values=['l1', 'l2'])))

    model.add(layers.Dropout(hp.Float('dropout_rate', min_value=0.2, max_value=0.5, step=0.1)))
    model.add(layers.Dense(1, activation='sigmoid'))

    model.compile(optimizer=keras.optimizers.get(hp.Choice('optimizer', values=['adam', 'rmsprop', 'sgd'])),
                  loss=hp.Choice('loss', values=['binary_crossentropy']),
                  metrics=['accuracy'])

    return model

tuner = RandomSearch(build_model,
                     objective='val_loss',
                     max_trials=5,
                     directory='my_tuner_directory',
                     project_name='my_tuner_project')

tuner.search(X_train_processed, y_train_encoded, epochs=50, validation_data=(X_test_processed, y_test_encoded))

tuner.get_best_hyperparameters()[0].values

model=tuner.get_best_models(num_models=1)[0]
callback=EarlyStopping(verbose=1,patience=1)
history=model.fit(X_train_processed,y_train_encoded,epochs=100,validation_data=(X_test_processed,y_test_encoded),callbacks=callback)

# Display model summary
model.summary()

# Get the list of all metric names
metrics_names = model.metrics_names

# Print all metrics
for metric_name in metrics_names:
    print(f"{metric_name}: {model.evaluate(X_test_processed, y_test_encoded, verbose=0, return_dict=True)[metric_name]}")

import matplotlib.pyplot as plt

plt.figure(figsize=(12, 6))

# Plot validation accuracy
plt.subplot(1, 2, 1)
plt.plot(history.history['val_accuracy'], label='Validation Accuracy')
plt.title('Validation Accuracy vs. Epochs')
plt.xlabel('Epochs')
plt.ylabel('Validation Accuracy')
plt.legend()

# Plot validation loss
plt.subplot(1, 2, 2)
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.title('Validation Loss vs. Epochs')
plt.xlabel('Epochs')
plt.ylabel('Validation Loss')
plt.legend()

plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
plt.figure(figsize=(12, 6))

# Plot accuracy
plt.subplot(1, 2, 1)
plt.plot(history.history['accuracy'], label='Training Accuracy')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy')
plt.title('Training vs Validation Accuracy')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.legend()

# Plot loss and validation loss
plt.subplot(1, 2, 2)
plt.plot(history.history['loss'], label='Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.title('Training vs Validation Loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()

plt.tight_layout()
plt.show()

